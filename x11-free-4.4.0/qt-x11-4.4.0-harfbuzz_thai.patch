diff -Nur qt-x11-opensource-src-4.4.0.orig/src/3rdparty/harfbuzz/src/harfbuzz-shaper-all.cpp qt-x11-opensource-src-4.4.0/src/3rdparty/harfbuzz/src/harfbuzz-shaper-all.cpp
--- qt-x11-opensource-src-4.4.0.orig/src/3rdparty/harfbuzz/src/harfbuzz-shaper-all.cpp	2008-04-28 20:11:15.000000000 +0700
+++ qt-x11-opensource-src-4.4.0/src/3rdparty/harfbuzz/src/harfbuzz-shaper-all.cpp	2008-07-22 12:55:29.000000000 +0700
@@ -8,5 +8,6 @@
 #include "harfbuzz-arabic.c"
 #include "harfbuzz-hangul.c"
 #include "harfbuzz-myanmar.c"
+#include "harfbuzz-thai.c"
 }
 
diff -Nur qt-x11-opensource-src-4.4.0.orig/src/3rdparty/harfbuzz/src/harfbuzz-shaper.cpp qt-x11-opensource-src-4.4.0/src/3rdparty/harfbuzz/src/harfbuzz-shaper.cpp
--- qt-x11-opensource-src-4.4.0.orig/src/3rdparty/harfbuzz/src/harfbuzz-shaper.cpp	2008-04-28 20:11:15.000000000 +0700
+++ qt-x11-opensource-src-4.4.0/src/3rdparty/harfbuzz/src/harfbuzz-shaper.cpp	2008-07-23 12:17:41.000000000 +0700
@@ -570,8 +570,6 @@
     return true;
 }
 
-static HB_AttributeFunction thai_attributes = 0;
-
 const HB_ScriptEngine HB_ScriptEngines[] = {
     // Common
     { HB_BasicShape, 0},
@@ -610,7 +608,7 @@
     // Sinhala
     { HB_IndicShape, HB_IndicAttributes },
     // Thai
-    { HB_BasicShape, thai_attributes },
+    { HB_BasicShape, HB_ThaiAttributes },
     // Lao
     { HB_BasicShape, 0 },
     // Tibetan
diff -Nur qt-x11-opensource-src-4.4.0.orig/src/3rdparty/harfbuzz/src/harfbuzz-shaper-private.h qt-x11-opensource-src-4.4.0/src/3rdparty/harfbuzz/src/harfbuzz-shaper-private.h
--- qt-x11-opensource-src-4.4.0.orig/src/3rdparty/harfbuzz/src/harfbuzz-shaper-private.h	2008-04-28 20:11:15.000000000 +0700
+++ qt-x11-opensource-src-4.4.0/src/3rdparty/harfbuzz/src/harfbuzz-shaper-private.h	2008-07-22 22:24:27.000000000 +0700
@@ -101,6 +101,8 @@
 
 extern void HB_IndicAttributes(HB_Script script, const HB_UChar16 *string, hb_uint32 from, hb_uint32 len, HB_CharAttributes *attributes);
 
+extern void HB_ThaiAttributes (HB_Script script, const HB_UChar16 *string, hb_uint32 from, hb_uint32 len, HB_CharAttributes *attributes);
+
 typedef struct {
     hb_uint32 tag;
     hb_uint32 property;
diff -Nur qt-x11-opensource-src-4.4.0.orig/src/3rdparty/harfbuzz/src/harfbuzz-thai.cpp qt-x11-opensource-src-4.4.0/src/3rdparty/harfbuzz/src/harfbuzz-thai.cpp
--- qt-x11-opensource-src-4.4.0.orig/src/3rdparty/harfbuzz/src/harfbuzz-thai.cpp	2008-04-28 20:11:15.000000000 +0700
+++ qt-x11-opensource-src-4.4.0/src/3rdparty/harfbuzz/src/harfbuzz-thai.cpp	1970-01-01 07:00:00.000000000 +0700
@@ -1,71 +0,0 @@
-/*******************************************************************
- *
- *  Copyright 2007  Trolltech ASA
- *
- *  This is part of HarfBuzz, an OpenType Layout engine library.
- *
- *  See the file name COPYING for licensing information.
- *
- ******************************************************************/
-
-#if 0
-#include <qtextcodec.h>
-#include <qlibrary.h>
-
-
-static void thaiWordBreaks(const QChar *string, const int len, QCharAttributes *attributes)
-{
-#ifdef QT_NO_TEXTCODEC
-    Q_UNUSED(string);
-    Q_UNUSED(len);
-    Q_UNUSED(attributes);
-#else
-    typedef int (*th_brk_def)(const char*, int[], int);
-    static QTextCodec *thaiCodec = QTextCodec::codecForMib(2259);
-    static th_brk_def th_brk = 0;
-
-#ifndef QT_NO_LIBRARY
-    /* load libthai dynamically */
-    if (!th_brk && thaiCodec) {
-        th_brk = (th_brk_def)QLibrary::resolve(QLatin1String("thai"), "th_brk");
-        if (!th_brk)
-            thaiCodec = 0;
-    }
-#endif
-
-    if (!th_brk)
-        return;
-
-    QByteArray cstr = thaiCodec->fromUnicode(QString(string, len));
-
-    int brp[128];
-    int *break_positions = brp;
-    int numbreaks = th_brk(cstr.constData(), break_positions, 128);
-    if (numbreaks > 128) {
-        break_positions = new int[numbreaks];
-        numbreaks = th_brk(cstr.data(),break_positions, numbreaks);
-    }
-
-    for (int i = 0; i < len - 1; ++i)
-        attributes[i].lineBreakType = QCharAttributes::NoBreak;
-
-    for (int i = 0; i < numbreaks; ++i) {
-        if (break_positions[i] > 0)
-            attributes[break_positions[i]-1].lineBreakType = QCharAttributes::Break;
-    }
-
-    if (break_positions != brp)
-        delete [] break_positions;
-#endif // QT_NO_TEXTCODEC
-}
-
-
-static void thai_attributes( int script, const QString &text, int from, int len, QCharAttributes *attributes )
-{
-    Q_UNUSED(script);
-    Q_ASSERT(script == QUnicodeTables::Thai);
-    thaiWordBreaks(text.unicode() + from, len, attributes);
-}
-
-
-#endif
diff -Nur qt-x11-opensource-src-4.4.0.orig/src/3rdparty/harfbuzz/src/Makefile.am qt-x11-opensource-src-4.4.0/src/3rdparty/harfbuzz/src/Makefile.am
--- qt-x11-opensource-src-4.4.0.orig/src/3rdparty/harfbuzz/src/Makefile.am	2008-04-28 20:11:15.000000000 +0700
+++ qt-x11-opensource-src-4.4.0/src/3rdparty/harfbuzz/src/Makefile.am	2008-07-22 12:54:59.000000000 +0700
@@ -18,7 +18,8 @@
 	harfbuzz-hebrew.c \
 	harfbuzz-arabic.c \
 	harfbuzz-hangul.c \
-	harfbuzz-myanmar.c
+	harfbuzz-myanmar.c \
+	harfbuzz-thai.c
 
 EXTRA_SOURCES = harfbuzz.c
 
diff -Nur qt-x11-opensource-src-4.4.0.orig/src/3rdparty/harfbuzz/src/harfbuzz-thai.c qt-x11-opensource-src-4.4.0/src/3rdparty/harfbuzz/src/harfbuzz-thai.c
--- qt-x11-opensource-src-4.4.0.orig/src/3rdparty/harfbuzz/src/harfbuzz-thai.c	1970-01-01 07:00:00.000000000 +0700
+++ qt-x11-opensource-src-4.4.0/src/3rdparty/harfbuzz/src/harfbuzz-thai.c	2008-07-25 10:04:42.000000000 +0700
@@ -0,0 +1,180 @@
+/*
+ * Copyright (C) 2007  Trolltech ASA
+ *
+ * This is part of HarfBuzz, an OpenType Layout engine library.
+ *
+ * Copyright (C) 2008 Thanomsub Noppaburana <donga.nb@gmail.com>
+ * Copyright (C) 2007 Jakkapun Kwanroengjai <jakkapun@mm.co.th>
+ * Copyright (C) 2003 Pattara Kiatisevi <pattara-list@mm.co.th>
+ * Copyright (C) 2003 Theppitak Karoonboonyanan <thep@linux.thai.net>
+ *
+ * Permission is hereby granted, without written agreement and without
+ * license or royalty fees, to use, copy, modify, and distribute this
+ * software and its documentation for any purpose, provided that the
+ * above copyright notice and the following two paragraphs appear in
+ * all copies of this software.
+ *
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+ */
+
+#include "harfbuzz-shaper.h"
+#include "harfbuzz-shaper-private.h"
+#include <assert.h>
+#include <dlfcn.h>
+#include <signal.h>
+#include <stdio.h>
+
+#define LIBTHAI_MAJOR_0 "libthai.so.0"
+#define ucs2tis(wc)     (((wc) - 0x0E00 + 0x20)^0x80)
+
+/*
+ * UGLY CODE!!! redefines cause not linked with libthai directly
+ * if libthai changed please updated these ugly code too.
+ */
+struct thcell_t {
+    unsigned char base;      /**< base character */
+    unsigned char hilo;      /**< upper/lower vowel/diacritic */
+    unsigned char top;       /**< top-level mark */
+};
+typedef int (*th_brk_def)(const unsigned char*, int*, size_t);
+typedef size_t (*th_next_cell_def)(const unsigned char *, size_t, struct thcell_t *, int);
+
+static void *libthai_handle = NULL;
+static th_brk_def th_brk = NULL;
+static th_next_cell_def th_next_cell = NULL;
+
+void hbthai_on_program_exit ()
+{
+    if (libthai_handle) {
+        dlclose (libthai_handle);
+        th_brk = NULL;
+        th_next_cell = NULL;
+        libthai_handle = NULL;
+        printf ("\nLIBTHAI unloaded ... \n");
+    }
+}
+
+#if 0
+static int is_inst_signal = false;
+
+void hbthai_sig_handling(int /*signum*/)
+{
+    hbthai_on_program_exit ();
+    exit (0);
+}
+#endif
+
+static int init_libthai ()
+{
+    if (!libthai_handle) {
+        /* open libthai library */
+        libthai_handle = dlopen(LIBTHAI_MAJOR_0, RTLD_NOW);
+        if (libthai_handle) {
+            printf("\nLIBTHAI loaded ...\n");
+            dlerror ();
+            th_brk = (th_brk_def) dlsym (libthai_handle, "th_brk");
+            th_next_cell = (th_next_cell_def) dlsym (libthai_handle, "th_next_cell");
+
+            /* trap exiting of program for unload libthai */
+            atexit (hbthai_on_program_exit);
+#if 0
+            /* install signal handler for trap any signals */
+            if (!is_inst_signal) {
+                is_inst_signal = true;
+                signal (SIGINT,  hbthai_sig_handling);
+                signal (SIGTERM, hbthai_sig_handling);
+                signal (SIGSEGV, hbthai_sig_handling);
+                signal (SIGILL,  hbthai_sig_handling);
+                signal (SIGKILL, hbthai_sig_handling);
+            }
+#endif
+        }
+        else
+            printf("\nCan't load libthai ... :-(\n");
+    }
+    return (libthai_handle != NULL);
+}
+
+/* getChar - Taken from scribus project */
+static HB_UChar32 HB_getChar (const HB_UChar16 *string, hb_uint32 length, hb_uint32 &i)
+{
+    HB_UChar32 ch;
+    if (HB_IsHighSurrogate(string[i])
+            && i < length - 1
+            && HB_IsLowSurrogate(string[i + 1])) {
+        ch = HB_SurrogateToUcs4(string[i], string[i + 1]);
+        ++i;
+    }
+    else {
+        ch = string[i];
+    }
+    return ch;
+}
+
+/* DO NOTHING: unassigned to HB_ScriptEngine yet, waiting for edited (if needed) */
+HB_Bool HB_ThaiShape (HB_ShaperItem */*shaper_item*/)
+{
+    return FALSE;
+}
+
+void HB_ThaiAttributes (HB_Script /*script*/, const HB_UChar16 *string, hb_uint32 from, hb_uint32 len, HB_CharAttributes *attributes)
+{
+    unsigned char tis_text[len];
+    struct thcell_t tis_cell;
+    hb_uint32 brk_n, i, j, cell_length;
+    int *brk_pnts = NULL;
+    const HB_UChar16 *ucs = string + from;
+    attributes += from;
+
+    /* Initial Libthai and related function(s) */
+    if (!init_libthai())
+        return;
+
+    /* translate input string to tis */
+    for (hb_uint32 idx = 0; idx < len; ++idx) {
+        tis_text[idx] = (unsigned char) ucs2tis ( HB_getChar (ucs, len, idx) );
+        attributes[idx].lineBreakType = HB_NoBreak;
+        attributes[idx].wordBoundary = false;
+    }
+    tis_text[len] = '\0';
+
+    brk_pnts = (int*) malloc (sizeof(int) * len);
+    if (brk_pnts) {
+        memset (brk_pnts, 0, sizeof(int) * len);
+
+        /* manage line break positions */
+        brk_n = th_brk ((const unsigned char*)tis_text, brk_pnts, len);
+        for (i = 0; i < brk_n; i++) {
+            if (brk_pnts[i] > 0) {
+                attributes[brk_pnts[i]-1].lineBreakType = HB_Break;
+                attributes[brk_pnts[i]-1].wordBoundary = true;
+            }
+        }
+        free (brk_pnts);
+    }
+
+    /* manage charStop */
+    i = 0;
+    while (i < len) {
+        cell_length = th_next_cell ((const unsigned char*)tis_text + i, len - i, &tis_cell, true);
+        attributes[i].charStop = true;
+        for(j = 1;j < cell_length;j++)
+            attributes[i + j].charStop = false;
+
+        /* Set Char Stop SARA AM */
+        if (tis_text[i + cell_length - 1] == 0xd3) {
+            attributes[i + cell_length - 1].charStop = true;
+        }
+        i += cell_length;
+    }
+}
